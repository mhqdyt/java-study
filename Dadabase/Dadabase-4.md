# 四.数据库的基本概念
## 1.表空间
### 1.1表空间是由一个或多个数据文件组成
* 通过表空间定义数据库对象文件的存放位置
* 数据库中所有的对象在逻辑中都存放在表空间中
* 在物理上储存在表空间所属的数据文件中
### 1.2表空间作用
* 根据数据库对象使用模式安排数据物理存放的位置，提高性能
* 通过表空间指定数据占用的物理磁盘空间
### 1.3系统内置表空间：GaussDB T创建时，系统预定义6个表空间
* SYSTEM：存放GaussDB T的元数据
* TEMP：当用户的SQL语句需要磁盘空间来完成某个操作时，GaussDB T数据库会从TEMP表空间分配临时段
* UNDO：存放UNDO数据
* USERS：默认的用户表空间，创建新用户且m没有指定表空间时，该用户的所有信息会放入USE表空间
* TEMP2：存放NOLOGGING表数据
* TEMP2_UNDO：存放NOLOGGING表的Undo数据
![image](https://github.com/mhqdyt/java-study/blob/master/images/Dadabase-4/4-1.png)
## 2.数据库及数据库对象
### 2.1表
![image](https://github.com/mhqdyt/java-study/blob/master/images/Dadabase-4/4-2.png)
* 在关系数据库中，数据库表就是y一系列二维数组的集合
> * 用来代表和储存数据对象之间的关系
* 记录
> * 表中的每一行被称之为一个记录，由若干个字段组成
* 字段
> * 也成为域，表中的每一列称为一个字段
> * 每个字段都包含两个属性：列名和数据类型
* 表的存储方式
> * 按照数据的存储方式
>> * 行存储表（统计分析类查询，适合OLAP，数据挖掘等大型查询的应用查询）
>> * 列存储表 （点查询，适合OLTP，这种轻量级事务，大量写操作，数据增删改比较多的场景）
![image](https://github.com/mhqdyt/java-study/blob/master/images/Dadabase-4/4-3.png)
### 2.2临时表
* GaussDB T支持创建临时表
> * 临时表用来保存一个会话或者一个事务中需要的数据
> * 当会话退出或者用户提交和回滚事务的时候，临时表的数据自动清空，但表结构依旧存在
> * 临时表中的数据时临时的，过程性的，不需要和普通数据那样永久保存
* 临时表分为
> * 会话级临时表
> * 事务级临时表
### 2.3特殊表
* NOLOGGING表
* 指定NOLOGGING关键字，或者指定放在NOLOGGING表空间
> * NOLOGGING表不会记录Redo日志
> * 日志量减少提高数据写性能
> * 没有Redo日志，出现故障数据库重启后无法恢复
> * 适用对象：可靠性要求不高的非核心数据
* 分区
![image](https://github.com/mhqdyt/java-study/blob/master/images/Dadabase-4/4-4.png)
* 分区表是将大表的数据分成许多小的数据子集，称为分区
![image](https://github.com/mhqdyt/java-study/blob/master/images/Dadabase-4/4-5.png)
> * 范围分区表
> * 列表分区表
> * 哈希分区表
> * 间隔分区表
* 分区表的收益
> * 改善查询功能
> * 增强可用性
> * 方便维护
> * 均衡I/O
* 分区剪枝的原理：将分区对象的查询可以仅搜索自己关心的分区，提高检索效率
* 数据分布
![image](https://github.com/mhqdyt/java-study/blob/master/images/Dadabase-4/4-6.png)
> * GuassDB T分布式数据库的数据表时分散在所有的数据节点上的，所以创建表的时候需要指定分布列
> * 分布方式
>> * Hash：表数据通过Hash方式散列到集群中的所有DN
>> * Replication：集群中的每一个DN都有一分全量表数据
>> * List：表数据通过List方式分布到指定DN节点上
>> * Range：表数据通过Range方式分布到指定DN节点上
* 数据策略选择
> * 复制
>> * 适合于记录较小的表
>> * 表中数据在各节点上完全复制，各DN都有全量数据
* 分布列选择原则
> * 尽量选择离散值比较多的列，保证数据均匀分布，分布均匀是为了避免木桶效应，各个DN对等执行
> * 在满足第一条原则的情况下，不要选择存在常量过滤的列
> * 满足前两条原则的情况下，尽量选择关联字段或者聚合字段做分布列，这种方式是为了避免数据节点之间数据重分布，降低IO的开销从而提升关联操作和聚合操作的性能
![image](https://github.com/mhqdyt/java-study/blob/master/images/Dadabase-4/4-7.png)
### 2.4数据
* 基本数据类型
> * 数值类型
> * 字符类型
> * 二进制类型
> * 日期/时间类型
> * 布尔类型
> * 枚举类型等
* 复合数据类型
* 序列号类型
* 几何类型
![image](https://github.com/mhqdyt/java-study/blob/master/images/Dadabase-4/4-8.png)
* 字段设计建议
> * 尽量使用高效数据类型
>> * 尽量使用执行效率比较高的数据类型
>> * 尽量使用短字段的数据类型
>> * 使用一致的数据类型
> * 当多个表存在逻辑关系时，表示同一含义的字段应该使用相同的数据类型
> * 对于字符串数据，建议使用变长字符串数据类型，并指定最大长度
### 2.5视图
* 视图与基本表不同，不是物理上实际存在的，是一个虚表
![image](https://github.com/mhqdyt/java-study/blob/master/images/Dadabase-4/4-9.png)
* 视图的作用
> * 简化了操作，把经常使用的数据定义为视图
> * 安全性，用户只能查询和修改能看到的数据
> * 逻辑上的独立性，屏蔽了真实表的结构带来的影响
* 限制性
> * 性能问题：查询可能很简单，但是封装的试图语句很复杂
> * 修改限制：对于复杂视图，用户不能通过视图修改基表数据
### 2.6索引
* 索引提供指向存储在表的指定列中的数据值的指针，如同图书的目录，能够加快表的查询速度，但同时也增加了插入，更新和删除操作的处理时间
* 创建索引时的建议
> * 在经常需要搜索查询的列上创建索引
> * 在作为主键的列上创建索引
> * 在经常需要根据范围进行搜索的列上创建索引
> * 在经常需要排序的列上创建索引
> * 在经常使用WHERE的列上创建索引
> * 为经常出现在关键字ORDER BY，GROUP BY，DISTINCT后面的字段上建立索引
* 有效索引
> * 创建索引≠索引一定被使用
>> * 索引创建成功后，系统会自动判断何时引用索引，当系统认为使用索引比顺序扫描更快时，就会使用索引
>> * 索引创建成功后，必须和表保持同步以保证能够准确的找到数据，这样就增加l了数据操作的负荷
>> * 需要定期删除无用的索引
> * 判定方法
>> * 通过执行explain语句查看执行计划来判断是否使用索引
* 索引方式
![image](https://github.com/mhqdyt/java-study/blob/master/images/Dadabase-4/4-10.png)
### 2.7约束
* 数据的完整性是指数据的正确性和一致性，可以通过定义表时定义完整性约束
> * 完整性约束是一种规则，本身不占用数据库空间
> * 完整性约束和表结构定义一起保存在数据字段中
* 常见的约束类型
> * 唯一性和主键约束（UNIQUE/PRIMARY KEY）
> * 外键约束（FOREIGN KEY）
> * 检查约束（CHECK）
> * 非空约束（NOT NULL）
> * 默认约束（DEFAULT）
* 约束的设计
> * 如果能共从业务层补全字段值，就不建议使用DEFAULT约束，避免数据加载时产生不符合预期的结果
> * 给明确不存在NULL值的字段加上NOT NULL，优化器会对其进行自动优化
> * 给可以显式命名的约束显式命名，除了NOT NULL和DEFAULT约束外，其他约束都可以显式命名
### 2.8数据库对象间的关系
![image](https://github.com/mhqdyt/java-study/blob/master/images/Dadabase-4/4-11.png)
### 2.9事务
* 事务是用户定义的数据操作系列，这些操作作为y一个完整的工作单元执行
> * 一个事务内的所有语句作为一个整体，要么全部执行，要么全部不执行
* 事务结束的标记有两个
> * 正常结束，COMMIT（提交事务）
> * 异常结束，ROLLBACK（回滚事务）
* 事务处理模型
> * 显式事务：事务有显式的开始和结束标记
> * 隐式事务：每一条数据操作语句都自动地成为一个事务
* 事务特征-ACID
> * 原子性（Atomicity）：事务是数据库的逻辑工作单位，事务中的操作，要么都做，要么都不做
> * 一致性（Consistency）：事务的执行结果必须是使数据库从一个一致性状态转到另一个一致性状态
> * 隔离性（Isolation）：数据库中一个事务的执行不能被其他事务干扰。即一个事务的内部操作及使用的数据对其他事务是隔离的，并发执行的各个事务不能相互干扰
> * 持久性（Duiability）：事务一旦提交，对数据库中数据的改变是永久性，提交后的操作或者故障不会对事务的操作结果产生任何影响
### 2.10数据不一致情况-脏读
* "Dirty" Reads(脏读）
> * 一个事务读取到了其他事务还没有提交（Committed）的数据
> * 因为未提交数据存在回滚的可能，所以被称为“脏”数据
![image](https://github.com/mhqdyt/java-study/blob/master/images/Dadabase-4/4-12.png)
* Non-repeatable Reads（不可复读）
> * 一个事务所获取到的数据是可以被其他事务修改的
> * 一个事务在处理过程中多次读取同一个数据，这个数据是可能发生变化的，因此称为不能重复读
* Phantom Read（幻影读）
> * 是不可复读的更为特殊的一个场景
> * 事务T1按照一定条件读取数据后，事务T2删除了部分记录或者插入一些新的记录，这些变更的数据是满足where条件过滤的
> * 那么当T1再次按照相同条件读取数据时，就会发现莫名奇妙地少了一些数据
> * 这些变化地数据就被称为“幻影”数据
![image](https://github.com/mhqdyt/java-study/blob/master/images/Dadabase-4/4-13.png)
### 2.11事务隔离级别
* ANSI SQL标准定义了四种事务隔离级别来避免3种数据不一致的问题，事务等级从高到低
> * Serializable（序列化）
>> * 系统中所有事务以串行方式逐个执行，所以能避免所有数据bbu不一致情况
>> * 但是这种以排他方式来控制并发事务，串行化执行方式会导致事务排队，系统的并发量大幅下降，使用的时候绝对慎重
> * Repeatable read（可重复读）
>> * 一个事务一旦开始，事务过程中所读取的所有数据不允许被其他事务修改
>> * 这个隔离级别没有办法解决“幻影读”的问题
>> * 因为它只保护了它读取的数据不被修改，但是其他数据会被修改，如果其他数据被修改后恰好满足了当前事务的过滤条件（where）语句，那么就会发生“幻影读”的情况
> * Read Committed（已提交读）
>> * 一个事务能读取到其他事务提交过的数据
>> * 一个事务在处理过程中如果重复读取某一个数据，而且这个数据恰好被其他事务修改并提交了，那么当前重复读取数据的事务就会出现同一个数据前后不同的情况
>> * 在这个隔离级别会发生“不可重复读”的场景
> * Read Uncommitted（为提交读）
>> * 一个事务能读取到其他事务修改过的，但是还未提交的数据
>> * 数据被其他事务修改过，但是还没有提交，就存在回滚的可能性，这时候读取这些未提交的数据的情况就是“脏读”
>> * 这个隔离级别会发生“脏读”的场景
* 事务隔离级别与问题对应表
![image](https://github.com/mhqdyt/java-study/blob/master/images/Dadabase-4/4-14.png)
